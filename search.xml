<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[React的生命周期]]></title>
      <url>%2F2016%2F09%2F02%2FReact%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[前言tag:本文主要知识源自于chemdemo我认为学习一个库，在初识了语法规范之后，接着要学习的就是生命周期了，生命周期方法告诉了我们在哪个阶段该做什么，对整个应用有一个直观的认识，并能清楚的控制。React的生命周期大体上分为：初始化，挂载，更新，卸载四个阶段。下面我们来看一下这四个阶段的详细方法。 初始化阶段。在这个阶段主要有俩个方法。初始化state123456constructor(props) &#123; super(props) this.state = &#123; name: props.name &#125;&#125; 初始化props123class.defaultProps = &#123; name:&apos;Zyan&apos;&#125; 如果属性没有从父组件传入的话可以直接使用此值作为默认examples:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123;Component, PropTypes&#125; from &apos;react&apos;import ReactDom from &apos;react-dom&apos;;class Lifecycle extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;initstate&apos;) this.state = &#123; name: props.name &#125; &#125; componentWillMount() &#123;&#125; componentDidMount() &#123;&#125; componentWillReceiveProps(nextProps) &#123;&#125; componentWillUpdate(nextProps, nextState) &#123;&#125; componentDidUpdate(prevProps, prevState) &#123;&#125; componentWillUnmount() &#123;&#125; click = (event) =&gt; &#123; this.setState(&#123;name: &quot;ni&quot;&#125;) &#125; render() &#123; console.log(&apos;render&apos;) return ( &lt;div&gt; &#123;this.state.name&#125; &lt;input type=&quot;button&quot; value=&quot;点击&quot; onClick=&#123;this.click&#125;/&gt; &lt;/div&gt; ) &#125;&#125;Lifecycle.propTypes = &#123; name:React.PropTypes.string&#125;Lifecycle.defaultProps = &#123; name:&apos;Zyan&apos;, conduct:function()&#123; console.log(&apos;initProps&apos;) &#125;()&#125;ReactDom.render( &lt;Lifecycle/&gt;, document.querySelector(&apos;#app&apos;)); 同时我们也可以看到执行顺序为props -&gt; state -&gt; render 挂载阶段此阶段有俩个方法可以使用：componentWillMount() 和componentDidMount() componentWillMount()在刚好初始渲染（initial rendering）发生之前被调用一次，也就是React在DOM插入组件之前。需要注意的是在此处调用this.setState()方法将不会触发重复渲染（re-render）componentDidMount()刚好发生在React插入组件到DOM之后，且也只被调用一次。在此方法能够之后DOM树已经构建完成，这意味着这个方法是初始化其他需要访问DOM或操作数据的第三方库的最佳时机。 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount 更新阶段当修改组件的props或者state时，组件将会进行更新。修改props时，会以此执行以下方法：12345componentWillReceiveProps(nextProps) &#123;&#125;shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 当state改变时执行以下方法：1234shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 此时组件已经被插入dom中了，所以这些方法不会在首次render时调用。 shouldComponentUpdate()方法允许我们自行决定下一个state更新时是否触发重复render。详细优化 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount -&gt; 更新 -&gt;willupdate -&gt; render -&gt; didUpdate 卸载阶段此阶段只有一个方法componentWillUnmount()它将在组件从DOM卸载之前被调用。可以在内部执行任何可能需要的清理工作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React优化指南]]></title>
      <url>%2F2016%2F09%2F01%2FReact%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[生命周期优化 shouldComponentUpdate(nextProps,nextState)此方法决定当prpos和state改变时是否执行render()。在有一些时候，我们并不需要刷新的时候，可以直接返回false。默认情况下是ture。此方法只会在组件的存在期调用，并不会在初始化期调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack构建前端项目]]></title>
      <url>%2F2016%2F08%2F27%2Fwebpack%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[介绍webpack是现在比较流行的前端构建工具，集编译，压缩，打包等功能于一体（webpack）。 本文将详细介绍webpack的使用 配置详解开发与生产环境配置注意事项 output中的path路径为绝对路径。 更改记录 output注意事项]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM标准事件的三个阶段]]></title>
      <url>%2F2016%2F08%2F26%2FDOM%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[事件捕获从根节点流向目标节点 目标阶段目标节点触发阶段 事件冒泡目标节点回溯到根节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown的基本使用]]></title>
      <url>%2F2016%2F08%2F25%2FMarkDown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、标题markDown的标题用”#”表示# 一级标题## 二级标题### 三级标题#### 四级标题 二、换行 在Markdown中插入换行标签&quot;&lt;br/&gt;&quot; 在行尾输入两个或以上的空格，然后回车 三、缩进 可以在段落前加&quot;- &quot; &amp;nbsp; 半角的不断行的空白格（推荐使用） &amp;ensp; 半角的空格 &amp;emsp; 全角的空格 输入法切换到全角，双击空格键 四、水平线 可以在单独一行里输入3个或以上的短横线、星号或者下划线实现* * ****----_____ 五、输出代码块使用“｀｀｀”符号吧代码段包裹住就可输出不执行了 12var a=1,b=2;console.log(a+b); 使用”`”包裹住方法可以输出方法 getName() 六、引用 如果要在一个引用里插入一个引用，可以用两个(‘&gt;’)开头。依此类推，根据嵌套层次加相应数量的符号。 这是一个引用 这是一个嵌套引用 这是一个嵌套引用 七、链接 链接可以在行内插入 [文字](链接地址) 另一种选择是，链接地址可以放在段落后面的脚注，前面放上链接引用标签区分。举例说，先在内容行内插入以下内容： [链接文字][链接引用标签] 然后在段落的后面（或者文档的结尾）放上以下内容，就可以生成一个链接： [链接引用标签]: 链接地址 &quot;链接标题&quot; 八、禁止转义 当做行内代码来处理添加” ` “ 内容 “ ` “ &amp;nbsp; 九、图片 ![图片描述](图片链接地址) 十、强调markdown 是一个具有*纯文本标记*特性的**轻量级**标记语言。 呈现效果 markdown 是一个具有纯文本标记特性的轻量级标记语言。 十一、居中 由于markdown没有居中对齐我们只能在内加入&lt;center&gt;内容&lt;/center&gt;标签&lt;center&gt;我是一个被居中的内容&lt;/center&gt;呈现效果: 我是一个被居中的内容 十二、列表 无序列表+ 列表项1- 列表项2* 列表项3 有序列表使用数字后面跟上句号。（还要有空格）1. 2. ...]]></content>
    </entry>

    
  
  
</search>
