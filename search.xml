<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[迈出校门一年来的感受]]></title>
      <url>%2F2016%2F09%2F05%2F%E8%BF%88%E5%87%BA%E6%A0%A1%E9%97%A8%E4%B8%80%E5%B9%B4%E6%9D%A5%E7%9A%84%E6%84%9F%E5%8F%97%2F</url>
      <content type="text"><![CDATA[经历一晃从学校出来工作已经一年了，在这一年中，换了三家公司。感觉总是安定不下来。公司越换越小。从七十来人的技术氛围良好的公司换到二十来人的以运营为主导的公司。然后回学校写毕设。再到如今从iOS换到了前端开发。在这一年中，技术的积累并没有按照理想中的进度进展。其实这二十多年好像自己定的计划从来没有完全实现。捂脸！！！但是确实还是感觉比在四年大学中学到的都多。也是忽然意识到自己意志力比较薄弱这个缺点…..只能在压力下进步，没有危机感……从15年的7月30日入职到元旦。在第一家公司五个月的时间里，学习到了基本的iOS开发技巧。基本上可以在IDE和网络的帮助下，驾轻就熟的完成一个app从架构到实现的过程。然后回学校准备毕设的开题辩论。 从元旦开始在学校的这段时间里，除了捣鼓毕设之外，就是寻找来年的工作了，充分感觉到了iOS开发的危机(对于我这种新手来说)。北京的iOS开发者在培训机构大力青睐的情况下，已经到了简历都不能筛出来的状态。遂开始准备后路，开始看前端开发的知识。同时脑子一热，答应帮助同学开发一款RN的安卓项目。 春节之后，来到北京继续找工作。很幸运来到了第二家公司。遇到了春哥。春哥是混过BAT的老手。在这一阶段的项目开发里教会了我很多。个人感觉最重要的就是学会了不懂就问。对滴，以前碰到不懂的地方我会发扬程序员孜孜不倦的精神，在网络里迷茫……（开玩笑）在有一个强大的技术导师的情况下还是问导师的好。 并没有在春哥的领导下很长时间，老师的一通电话就把我召唤回了学校。（不靠谱的学校说要提前一个月进行答辩，到最后自然是没有提前成功，对，学校就是这么不靠谱……）不过既然回来了就只能安安心心做毕设喽。 毕设的结果是在全系最严格的主任组中，得了全系第一名……对我四年每年挂俩科的大学生活画上了一个圆满的句号！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React的生命周期]]></title>
      <url>%2F2016%2F09%2F02%2FReact%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[前言tag:本文主要知识源自于chemdemo我认为学习一个库，在初识了语法规范之后，接着要学习的就是生命周期了，生命周期方法告诉了我们在哪个阶段该做什么，对整个应用有一个直观的认识，并能清楚的控制。React的生命周期大体上分为：初始化，挂载，更新，卸载四个阶段。下面我们来看一下这四个阶段的详细方法。 初始化阶段。在这个阶段主要有俩个方法。初始化state123456constructor(props) &#123; super(props) this.state = &#123; name: props.name &#125;&#125; 初始化props123class.defaultProps = &#123; name:&apos;Zyan&apos;&#125; 如果属性没有从父组件传入的话可以直接使用此值作为默认examples:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123;Component, PropTypes&#125; from &apos;react&apos;import ReactDom from &apos;react-dom&apos;;class Lifecycle extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;initstate&apos;) this.state = &#123; name: props.name &#125; &#125; componentWillMount() &#123;&#125; componentDidMount() &#123;&#125; componentWillReceiveProps(nextProps) &#123;&#125; componentWillUpdate(nextProps, nextState) &#123;&#125; componentDidUpdate(prevProps, prevState) &#123;&#125; componentWillUnmount() &#123;&#125; click = (event) =&gt; &#123; this.setState(&#123;name: &quot;ni&quot;&#125;) &#125; render() &#123; console.log(&apos;render&apos;) return ( &lt;div&gt; &#123;this.state.name&#125; &lt;input type=&quot;button&quot; value=&quot;点击&quot; onClick=&#123;this.click&#125;/&gt; &lt;/div&gt; ) &#125;&#125;Lifecycle.propTypes = &#123; name:React.PropTypes.string&#125;Lifecycle.defaultProps = &#123; name:&apos;Zyan&apos;, conduct:function()&#123; console.log(&apos;initProps&apos;) &#125;()&#125;ReactDom.render( &lt;Lifecycle/&gt;, document.querySelector(&apos;#app&apos;)); 同时我们也可以看到执行顺序为props -&gt; state -&gt; render 挂载阶段此阶段有俩个方法可以使用：componentWillMount() 和componentDidMount() componentWillMount()在刚好初始渲染（initial rendering）发生之前被调用一次，也就是React在DOM插入组件之前。需要注意的是在此处调用this.setState()方法将不会触发重复渲染（re-render）componentDidMount()刚好发生在React插入组件到DOM之后，且也只被调用一次。在此方法能够之后DOM树已经构建完成，这意味着这个方法是初始化其他需要访问DOM或操作数据的第三方库的最佳时机。 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount 更新阶段当修改组件的props或者state时，组件将会进行更新。修改props时，会以此执行以下方法：12345componentWillReceiveProps(nextProps) &#123;&#125;shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 当state改变时执行以下方法：1234shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 此时组件已经被插入dom中了，所以这些方法不会在首次render时调用。 shouldComponentUpdate()方法允许我们自行决定下一个state更新时是否触发重复render。详细优化 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount -&gt; 更新 -&gt;willupdate -&gt; render -&gt; didUpdate 卸载阶段此阶段只有一个方法componentWillUnmount()它将在组件从DOM卸载之前被调用。可以在内部执行任何可能需要的清理工作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React优化指南]]></title>
      <url>%2F2016%2F09%2F01%2FReact%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[生命周期优化 shouldComponentUpdate(nextProps,nextState)此方法决定当prpos和state改变时是否执行render()。在有一些时候，我们并不需要刷新的时候，可以直接返回false。默认情况下是ture。此方法只会在组件的存在期调用，并不会在初始化期调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack构建前端项目]]></title>
      <url>%2F2016%2F08%2F27%2Fwebpack%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[介绍webpack是现在比较流行的前端构建工具，集编译，压缩，打包等功能于一体（webpack）。 本文将详细介绍webpack的使用 配置详解开发与生产环境配置注意事项 output中的path路径为绝对路径。 更改记录 output注意事项]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM标准事件的三个阶段]]></title>
      <url>%2F2016%2F08%2F26%2FDOM%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[事件捕获从根节点流向目标节点 目标阶段目标节点触发阶段 事件冒泡目标节点回溯到根节点]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown的基本使用]]></title>
      <url>%2F2016%2F08%2F25%2FMarkDown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、标题markDown的标题用”#”表示# 一级标题## 二级标题### 三级标题#### 四级标题 二、换行 在Markdown中插入换行标签&quot;&lt;br/&gt;&quot; 在行尾输入两个或以上的空格，然后回车 三、缩进 可以在段落前加&quot;- &quot; &amp;nbsp; 半角的不断行的空白格（推荐使用） &amp;ensp; 半角的空格 &amp;emsp; 全角的空格 输入法切换到全角，双击空格键 四、水平线 可以在单独一行里输入3个或以上的短横线、星号或者下划线实现* * ****----_____ 五、输出代码块使用“｀｀｀”符号吧代码段包裹住就可输出不执行了 12var a=1,b=2;console.log(a+b); 使用”`”包裹住方法可以输出方法 getName() 六、引用 如果要在一个引用里插入一个引用，可以用两个(‘&gt;’)开头。依此类推，根据嵌套层次加相应数量的符号。 这是一个引用 这是一个嵌套引用 这是一个嵌套引用 七、链接 链接可以在行内插入 [文字](链接地址) 另一种选择是，链接地址可以放在段落后面的脚注，前面放上链接引用标签区分。举例说，先在内容行内插入以下内容： [链接文字][链接引用标签] 然后在段落的后面（或者文档的结尾）放上以下内容，就可以生成一个链接： [链接引用标签]: 链接地址 &quot;链接标题&quot; 八、禁止转义 当做行内代码来处理添加” ` “ 内容 “ ` “ &amp;nbsp; 九、图片 ![图片描述](图片链接地址) 十、强调markdown 是一个具有*纯文本标记*特性的**轻量级**标记语言。 呈现效果 markdown 是一个具有纯文本标记特性的轻量级标记语言。 十一、居中 由于markdown没有居中对齐我们只能在内加入&lt;center&gt;内容&lt;/center&gt;标签&lt;center&gt;我是一个被居中的内容&lt;/center&gt;呈现效果: 我是一个被居中的内容 十二、列表 无序列表+ 列表项1- 列表项2* 列表项3 有序列表使用数字后面跟上句号。（还要有空格）1. 2. ...]]></content>
    </entry>

    
  
  
</search>
