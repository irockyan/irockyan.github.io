<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Electron]]></title>
      <url>%2F2016%2F11%2F03%2FElectron%2F</url>
      <content type="text"><![CDATA[前言如果你只会JS，还想写一个GUI的话，相信你会喜欢这个技术。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记不住的JSAPI]]></title>
      <url>%2F2016%2F11%2F01%2F%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84jsAPI%2F</url>
      <content type="text"><![CDATA[将字符串分割成数组 1234function* split(string)&#123; yield* string&#125;console.log([...split(&apos;nihao&apos;)]); 或者直接使用扩展操作符 1[...&apos;nihao&apos;]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局]]></title>
      <url>%2F2016%2F10%2F27%2Fflex%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[详细注意设为Flex布局以后，子元素的float、clear和vertical-align属性将失效]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊一聊CSS中的盒模型]]></title>
      <url>%2F2016%2F10%2F27%2F%E8%81%8A%E4%B8%80%E8%81%8ACSS%E4%B8%AD%E7%9A%84%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[前言参考链接：盒模型 box-sizing基本大家都知道盒模型的概念，我就不再多说了，主要说一下其中的box-sizing属性。 box-sizing主要用来改变盒模型对于宽度和高度的计算，在实际中我们可以根据习惯，设置为符合自己计算思路的盒模型计算法则。有俩个值：content-box和border-boxcontent-box：默认值，计算宽度和高度值为content box的高度和宽度，不包括内边距，边框，外边距。border-box：可选值，高度和宽度包括内边距和边框。 各种长度的意思 offsetWidth是一个只读属性，返回一个元素的布局宽度。一个典型的offsetWidth是测量元素的边框(borders)、水平线上的内边距(padding)、竖直方向滚动条(scroolbar)（如果存在的话）、以及CSS设置的宽度(width)的值。 clientWidth属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有的话）、边框和外边距。该属性值会被四舍五入为一个整数。如果你需要一个小数值，可使用 element.getBoundingClientRect()。 innerWidth浏览器视口（viewport）宽度（单位：像素），如果存在垂直滚动条则包括它。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown的基本使用]]></title>
      <url>%2F2016%2F10%2F25%2FMarkDown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、标题markDown的标题用”#”表示# 一级标题## 二级标题### 三级标题#### 四级标题 二、换行 在Markdown中插入换行标签&quot;&lt;br/&gt;&quot; 在行尾输入两个或以上的空格，然后回车 三、缩进 可以在段落前加&quot;- &quot; &amp;nbsp; 半角的不断行的空白格（推荐使用） &amp;ensp; 半角的空格 &amp;emsp; 全角的空格 输入法切换到全角，双击空格键 四、水平线 可以在单独一行里输入3个或以上的短横线、星号或者下划线实现* * ****----_____ 五、输出代码块使用“｀｀｀”符号吧代码段包裹住就可输出不执行了 12var a=1,b=2;console.log(a+b); 使用”`”包裹住方法可以输出方法 getName() 六、引用 如果要在一个引用里插入一个引用，可以用两个(‘&gt;’)开头。依此类推，根据嵌套层次加相应数量的符号。 这是一个引用 这是一个嵌套引用 这是一个嵌套引用 七、链接 链接可以在行内插入 [文字](链接地址) 另一种选择是，链接地址可以放在段落后面的脚注，前面放上链接引用标签区分。举例说，先在内容行内插入以下内容： [链接文字][链接引用标签] 然后在段落的后面（或者文档的结尾）放上以下内容，就可以生成一个链接： [链接引用标签]: 链接地址 &quot;链接标题&quot; 八、禁止转义 当做行内代码来处理添加” ` “ 内容 “ ` “ &amp;nbsp; 九、图片 ![图片描述](图片链接地址) ![](static/file.png)本地链接 十、强调markdown 是一个具有*纯文本标记*特性的**轻量级**标记语言。 呈现效果 markdown 是一个具有纯文本标记特性的轻量级标记语言。 十一、居中 由于markdown没有居中对齐我们只能在内加入&lt;center&gt;内容&lt;/center&gt;标签&lt;center&gt;我是一个被居中的内容&lt;/center&gt;呈现效果: 我是一个被居中的内容 十二、列表 无序列表+ 列表项1- 列表项2* 列表项3 有序列表使用数字后面跟上句号。（还要有空格）1. 2. ...]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue学习记录]]></title>
      <url>%2F2016%2F10%2F23%2Fvue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[前言vue有着近乎同步更新的文档地址。推荐使用官方脚手架搭建项目。本文案例主要讲自己工作的技术栈需要配置的东西。如果依赖被墙，请自行搜索npm淘宝镜像。 依赖插件 sass-loader与node-sass用来处理scss。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[16.10.22]]></title>
      <url>%2F2016%2F10%2F22%2F16-10-22%2F</url>
      <content type="text"><![CDATA[perspective相当于井深，这个属性值越深，表示立体感越深。 ##]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[必备知识收藏]]></title>
      <url>%2F2016%2F10%2F22%2F%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[语义化版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[16.10.21]]></title>
      <url>%2F2016%2F10%2F21%2F16-10-21%2F</url>
      <content type="text"><![CDATA[异常并不会阻碍代码的执行，只是抛出错误信息。 异常要用Error的对象而不要自定义对象，因为只有Err的对象才能获取到上下文。 我们可以为任意的对象添加属性，包括内建对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[facebook新品：yarn]]></title>
      <url>%2F2016%2F10%2F20%2Ffacebook%E6%96%B0%E5%93%81%EF%BC%9Ayarn%2F</url>
      <content type="text"><![CDATA[介绍yarn是facebook出品的js包管理工具。用于替代npm。优势就是安全，下载速度快。 命令npm i -g yarn安装。yarn add $package作用等同于npm i --save $package]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[梳理line-height]]></title>
      <url>%2F2016%2F10%2F02%2F%E6%A2%B3%E7%90%86line-height%2F</url>
      <content type="text"><![CDATA[当没有显示声明line-height的时候]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何禁止chrome的缓存]]></title>
      <url>%2F2016%2F10%2F01%2F%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2chrome%E7%9A%84%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[在我们做一些图片加载效果的过程中，为了每次都让图片重新加载，可以在开发chrome的开发工具里打开更多，然后是more tools，然后是network condictions。在这里可以禁止缓存，并且模拟网速。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML收藏]]></title>
      <url>%2F2016%2F09%2F30%2FHTML%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[HTML5沿革]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小知识合集]]></title>
      <url>%2F2016%2F09%2F11%2F%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86%2F</url>
      <content type="text"><![CDATA[高度的百分比需要继承在父元素未设置高度的情况下，子元素的高度的按百分比显示的话需要将父元素的高度一直写到确切的高度为止。123456789101112html&#123; height: 100%;&#125;body&#123; height: 100%;&#125;.father&#123; height: 100%;&#125;.child&#123; height: 100%;&#125; 宽度无此限制 var的变量提升(hoist)使用var声明的变量的变量会提升到作用域的顶部。例如1234console.log(n);n = &apos;nihao&apos;console.log(n);var n; em的规则font-size的值如果为em，继承的是父级的高度，如果其他值为em的话，根据的是当前元素的font-size的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计类收藏]]></title>
      <url>%2F2016%2F09%2F10%2F%E8%AE%BE%E8%AE%A1%E7%B1%BB%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[设计更好的表单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vscode使用指南]]></title>
      <url>%2F2016%2F09%2F09%2Fvscode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[简介微软在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。推荐理由：免费，开源。下载地址 我的设置vsc的个性化设置我感觉还是比较方便的。进入首选项用户设置就可以进行设置。下载完成之后我首先改了对于文件修改保存的设置，默认是需要手动保存的，我改成了自动保存。然后就是默认的shell，对于win10用户我感觉可以换成ubuntu的那个shell，默认应该是和cmd在同一级目录。 插件建议 vscode-icons：这个是一个图标插件，vsc自带的插件对于各种文件的显示效果没有明显的区分。本插件比较好看，可以清楚的辨别各种文件类型。效果如图。 安装好之后在首选项里选择文件主题图标选择本插件就好。 Auto Rename Tag：书写HTML的时候，当更改了开始标签时，闭合标签也会自动改变。 快捷键虽然可以直接在偏好设置里查看默认的键盘快捷键和自定义快捷键，但是估计一票人不会去看。 文本编辑alt+up/down 移动单行shift+alt+up/down 向上或者下复制单行shift+alt+f 格式化文本command++/- 增大或者减小文本字体 文本选择li*10 直接写出10行alt+鼠标选择 选择行command+alt+up/down [size=0.9em]多行选择shift+up/down 选中光标前或者后一行shift+command+left/right 选中左或者右的部分shift+command+down/up 选中光标前面所有或者后面所有内容 文本跳转ctrl+a 跳到本行开始（command＋left）ctrl+e 跳到本行末尾（我自己喜欢用command＋right）command+down/up 跳到开始或者结束的位置 窗口切换command+b 切换二级菜单 命令code .在vscode中打开当前文件夹]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm使用技巧]]></title>
      <url>%2F2016%2F09%2F08%2Fnpm%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[前言本文主要知识来自于文蔺 npm算是前端开发中最常用的一个工具了，掌握一些技巧对于提高编程效率增加幸福感至关重要。 打开npm包的官网在开发中并不是都对每一个包都了如指掌，所以需要经常要去官网看文档npm home $package比如npm home react 打开此包的GitHub地址和上边一个命令差不太多npm repo $package 检查依赖中的过时项npm outdated这个对于我这种升级强迫症来说简直是完美。但是升级需谨慎。 删除无用的依赖项npm prune此命令可以删除node-modules中不在依赖列表中的项，对于实验某些依赖的作用或者删除年少轻狂时犯下的错有很大的作用。 下边是一些常用配置 创建package.json文件npm initnpm init -y两者区别自行尝试 安装依赖npm install --save react安装生产环境依赖npm install --save-dev webpack开发环境依赖npm install -g全局安装tips:install可以简写为i npm脚本既是shell脚本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见网络安全名词介绍]]></title>
      <url>%2F2016%2F09%2F06%2F%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[XSS跨站脚本攻击(Cross Site Scripting) CSRF跨站请求伪造(Cross-site request forgery) SQL注入 CSP网页安全政策(Content Security Policy)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React的生命周期]]></title>
      <url>%2F2016%2F09%2F02%2FReact%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[前言tag:本文主要知识源自于chemdemo我认为学习一个库，在初识了语法规范之后，接着要学习的就是生命周期了，生命周期方法告诉了我们在哪个阶段该做什么，对整个应用有一个直观的认识，并能清楚的控制。React的生命周期大体上分为：初始化，挂载，更新，卸载四个阶段。下面我们来看一下这四个阶段的详细方法。 初始化阶段。在这个阶段主要有俩个方法。初始化state123456constructor(props) &#123; super(props) this.state = &#123; name: props.name &#125;&#125; 初始化props123class.defaultProps = &#123; name:&apos;Zyan&apos;&#125; 如果属性没有从父组件传入的话可以直接使用此值作为默认examples:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123;Component, PropTypes&#125; from &apos;react&apos;import ReactDom from &apos;react-dom&apos;;class Lifecycle extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;initstate&apos;) this.state = &#123; name: props.name &#125; &#125; componentWillMount() &#123;&#125; componentDidMount() &#123;&#125; componentWillReceiveProps(nextProps) &#123;&#125; componentWillUpdate(nextProps, nextState) &#123;&#125; componentDidUpdate(prevProps, prevState) &#123;&#125; componentWillUnmount() &#123;&#125; click = (event) =&gt; &#123; this.setState(&#123;name: &quot;ni&quot;&#125;) &#125; render() &#123; console.log(&apos;render&apos;) return ( &lt;div&gt; &#123;this.state.name&#125; &lt;input type=&quot;button&quot; value=&quot;点击&quot; onClick=&#123;this.click&#125;/&gt; &lt;/div&gt; ) &#125;&#125;Lifecycle.propTypes = &#123; name:React.PropTypes.string&#125;Lifecycle.defaultProps = &#123; name:&apos;Zyan&apos;, conduct:function()&#123; console.log(&apos;initProps&apos;) &#125;()&#125;ReactDom.render( &lt;Lifecycle/&gt;, document.querySelector(&apos;#app&apos;)); 同时我们也可以看到执行顺序为props -&gt; state -&gt; render 挂载阶段此阶段有俩个方法可以使用：componentWillMount() 和componentDidMount() componentWillMount()在刚好初始渲染（initial rendering）发生之前被调用一次，也就是React在DOM插入组件之前。需要注意的是在此处调用this.setState()方法将不会触发重复渲染（re-render）componentDidMount()刚好发生在React插入组件到DOM之后，且也只被调用一次。在此方法能够之后DOM树已经构建完成，这意味着这个方法是初始化其他需要访问DOM或操作数据的第三方库的最佳时机。 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount 更新阶段当修改组件的props或者state时，组件将会进行更新。修改props时，会以此执行以下方法：12345componentWillReceiveProps(nextProps) &#123;&#125;shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 当state改变时执行以下方法：1234shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 此时组件已经被插入dom中了，所以这些方法不会在首次render时调用。 shouldComponentUpdate()方法允许我们自行决定下一个state更新时是否触发重复render。详细优化 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount -&gt; 更新 -&gt;willupdate -&gt; render -&gt; didUpdate 卸载阶段此阶段只有一个方法componentWillUnmount()它将在组件从DOM卸载之前被调用。可以在内部执行任何可能需要的清理工作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React优化指南]]></title>
      <url>%2F2016%2F09%2F01%2FReact%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[生命周期优化 shouldComponentUpdate(nextProps,nextState)此方法决定当prpos和state改变时是否执行render()。在有一些时候，我们并不需要刷新的时候，可以直接返回false。默认情况下是ture。此方法只会在组件的存在期调用，并不会在初始化期调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack构建前端项目]]></title>
      <url>%2F2016%2F08%2F27%2Fwebpack%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[介绍webpack是现在比较流行的前端构建工具，集编译，压缩，模块加载，打包等功能于一体（webpack）。 本文将详细介绍webpack的使用 配置与名词详解 chunk打包完成之后的块 entry构建模块的起点，每一个入口文件对应生成一个chunk。开发与生产环境配置注意事项 output中的path路径为绝对路径。 更改记录 output注意事项 entry的解释[2016,09,07]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM标准事件的三个阶段]]></title>
      <url>%2F2016%2F08%2F26%2FDOM%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[事件捕获从根节点流向目标节点 目标阶段目标节点触发阶段 事件冒泡目标节点回溯到根节点]]></content>
    </entry>

    
  
  
</search>
