<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[获取客户端的图片]]></title>
      <url>%2F2017%2F03%2F21%2F%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%9B%BE%E7%89%87%2F</url>
      <content type="text"><![CDATA[前言最近总是做移动端的项目，有一个获取本地图片的功能需要实现。本例子要实现的功能： 本地上传图片到服务器。 从服务器拉取图片到本地，并且实现滤镜效果。 iOS与移动端实现效果一致。 利用input标签上代码 1&lt;input type="file" accept="image/*" capture="camera"&gt; accept接受的是file的文件类型。此段代码可以选取客户端的图片。随后 1234567var camera = document.querySelector('input');var img = document.querySelector('img');camera.addEventListener('change',(e) =&gt; &#123; var file = e.target.files[0]; img.src = URL.createObjectURL(file);&#125;) 可以将文件获取出来并显示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Animate.css]]></title>
      <url>%2F2017%2F03%2F17%2FAnimate-css%2F</url>
      <content type="text"><![CDATA[介绍是一个CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。 常用属性.animated bounce 动画 回弹效果.animated shake 动画 抖动animated fadeOut 淡出animated hinge 悬挂到左侧，然后消失]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F03%2F16%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[元字符() 在正则表达式中可以被用作是一个记忆设备。这一部分正则所匹配的字符将会被记住，在后面可以被利用\1 可以引用括号中的内容。* 前边一项出现了一个或者多个,等价于 {0,}。+ 匹配前面一个表达式1次或者多次。等价于 {1,}。? 匹配前面一个表达式0次或者1次。等价于 {0,1}。\ 转义字符^ 匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。$ 匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。\b 匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）\w 匹配一个单字字符（字母、数字或者下划线)。等价于[A-Za-z0-9_]。\d 匹配一个数字，等价于[0-9]。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BootStrap使用]]></title>
      <url>%2F2017%2F03%2F16%2FBootStrap%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[类名.container 类用于固定宽度并支持响应式布局的容器。.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 .row 在一行内 .img-responsive 类可以让图片支持响应式布局。其实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性，从而让图片在其父元素中更好的缩放。text-center 文本居中text-danger 文字危险颜色text-primary 文本蓝色 btn 按钮，长度与文本长度一样。btn btn-block 你的按钮将会伸展并填满页面整个水平空间，任何在它之下的元素都会跟着浮动至该区块的下一行。btn btn-block btn-default 默认按钮btn btn-block btn-primary 蓝色的块级按钮。btn btn-block btn-info 浅蓝色的块级按钮。btn btn-block btn-danger 按钮危险 fa fa-thumbs-up 字体图标 点赞fa fa-info-circle 字体图标 信息fa fa-trash 字体图标 删除fa fa-paper-plane 字体图标 飞机 提交 form-control 所有设置了 .form-control 类的 &lt;tinput&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%; 4.0变化已废弃.well well，它的作用是为设定的列创造出一种视觉上的深度感(4.0中已废弃)cite 默认没有-了blockquote padding清除。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己实现响应式网格（栅格化）布局]]></title>
      <url>%2F2017%2F03%2F14%2F%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E6%A0%BC%EF%BC%88%E6%A0%85%E6%A0%BC%E5%8C%96%EF%BC%89%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见排序算法]]></title>
      <url>%2F2017%2F03%2F10%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[插入排序123456789101112131415var array = [];for(let i=0; i&lt;10; i++)&#123; array.push(Math.floor(Math.random()*10+1));&#125;console.log(array);for(let i=1; i&lt;array.length; i++)&#123; for(let j=0; j&lt;i; j++)&#123; if(array[i] &lt; array[j])&#123; var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125;&#125;console.log(array); 冒泡排序快速排序二分归并排序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试题]]></title>
      <url>%2F2017%2F03%2F07%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[相关引用你有必要知道的 25 个 JavaScript 面试题 HTMLCSS 什么是BFC？详情见BFC JS 使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？typeof为操作符，返回判断的参数类型。但是并不是特别精确，除了五种基本数据类型外，都会返回object精确判断类型可以使用Object.prototype.toString.call(obj)空字符串与空数组判定为true。a instanceof Array 可以判断是否是数组。Array.isArray() ES5中新增的方法。 下面的代码会在 console 输出神马？为什么？ 123456(function()&#123; var a = b = 3;&#125;)();console.log(&quot;a defined? &quot; + (typeof a !== &apos;undefined&apos;)); console.log(&quot;b defined? &quot; + (typeof b !== &apos;undefined&apos;)); 在js中如果没有被var修饰的话是全局变量。 下面的代码会在 console 输出神马？为什么？ 12345678910111213var myObject = &#123; foo: &quot;bar&quot;, func: function() &#123; var self = this; console.log(&quot;outer func: this.foo = &quot; + this.foo); console.log(&quot;outer func: self.foo = &quot; + self.foo); (function() &#123; console.log(&quot;inner func: this.foo = &quot; + this.foo); console.log(&quot;inner func: self.foo = &quot; + self.foo); &#125;()); &#125;&#125;;myObject.func(); 在ES6之前，js中只有函数作用域。 将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？ 12345for(var i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 1000);&#125; 这里说一下setTimeout()的执行时机，会在同步代码执行完毕之后才会执行。 关于末尾引号的问题。return,continue,break等语句如果单独在一行，解释器会在末尾自动添加引号。 神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?Number.isNan()会隐式的进行类型转换。 解释一下下面代码的输出 12console.log(0.1 + 0.2); //0.30000000000000004console.log(0.1 + 0.2 == 0.3); //false 写一个少于 80 字符的函数，判断一个字符串是不是回文字符串 1234function isPalindrome(str) &#123; str = str.replace(/\W/g, &apos;&apos;).toLowerCase(); return (str == str.split(&apos;&apos;).reverse().join(&apos;&apos;));&#125; 解释一下回文字符串。就是一个字符串，从左到右读和从右到左读是完全一样的。 写出操作节点常用的方法？ 添加子节点appendChild() 添加到某个节点的前边insertBefore() 替换某个节点replaceChild() 删除某个节点removeChild() document.onload和window.onload有什么区别?document.onload 是在结构和样式加载完才执行jswindow.onload：不仅仅要在结构和样式加载完，还要执行完所有的样式、图片这些资源文件，全部加载完才会触发window.onload事件 编写一个数组去重的方法？ 12345678const array = [1, 1, 12, 2, 14, 1, 41, 42, 525252, 112, 1, 235, 632], newArray = [];for (let i = 0; i &lt; array.length; i++) &#123; newArray.indexOf(array[i]) &lt; 0 &amp;&amp; newArray.push(array[i]);&#125;console.log(newArray); 看下边代码输出什么？ 12345a.value = 1;var b = a;b.value = 2;console.log(b.value);console.log(a.value); 看下边代码会输出什么？ 123var foo = 11+&quot;2&quot;-1;console.log(foo);//111console.log(typeof foo); 加法会进行字符串链接，减法会进行隐式转换。 将‘get-element-by-id’变成驼峰写法? 123456789var foo = &apos;get-element-by-id&apos;, fooArr = [&apos;get&apos;];var c = foo.split(&apos;-&apos;);for (let i = 1; i &lt; c.length; i++) &#123; var ele = c[i]; var b = ele.charAt(0).toUpperCase(); var aa = ele.replace(ele.charAt(0),b); fooArr.push(aa);&#125; 网站优化 如何优化加载大量图片的网站（电商类）? 压缩图片图片可以使用webp格式。首先要验证webp的兼容性并解决兼容性问题。以及如何将图片变成webp的格式。 兼容性：谷歌系支持 验证当前浏览器是否支持，然后分情况处理。 优化加载流程 优化加载效果 添加滤镜效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017-03-06]]></title>
      <url>%2F2017%2F03%2F06%2F2017-03-06%2F</url>
      <content type="text"><![CDATA[关于js中移动可以选择用定位或者transform来做，定位的话会触发重新渲染。但是transform每次获取的是原来的坐标。如果需要做连续的话，需要定义一个全局的值，来对变量进行存储。 border中当颜色值进行缺省的时候，会将color的值作为border的颜色的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[即将到来的邮件设计革命]]></title>
      <url>%2F2017%2F03%2F04%2F%E5%8D%B3%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84%E9%82%AE%E4%BB%B6%E8%AE%BE%E8%AE%A1%E9%9D%A9%E5%91%BD%2F</url>
      <content type="text"><![CDATA[翻译自The Coming Revolution in Email Design Email, the web’s much maligned little cousin, is in the midst of a revolution—one that will change not only how designers and developers build HTML email campaigns, but also the way in which subscribers interact with those campaigns.邮件，web的饱受诟病的小表弟，正处在变革之中。这不仅将改变设计者和开发者创建HTML邮件的方式，同时也会改变用户与之交互的方式。Despite the slowness of email client vendors to update their rendering engines, email designers are developing new ways of bringing commonplace techniques on the web to the inbox. Effects like animation and interactivity are increasingly used by developers to pull off campaigns once thought impossible. And, for anyone coming from the world of the web, there are more tools, templates, and frameworks than ever to make that transition as smooth as possible. For seasoned email developers, these tools can decrease email production times and increase the reliability and efficacy of email campaigns.尽管，邮件客户端的提供商对于更新他们现有的设计非常缓慢，邮件设计者正在设计新的方法来为收件箱带来一些老生常谈的技巧。像动画和交互一旦想法可行就会被越来越多的开发者从规范中移除。同时，对于来自于web世界的任何一个人来说，都有越来越多的工具，模版，和框架来使转场变得越来越平滑。对于经验丰富的开发者来说，这些工具能够减少生产邮件的时间和增加邮件这种通信模式的可靠性和影响。Perhaps more importantly, the email industry itself is in a state of reinvention. For the first time, email client vendors—traditionally hesitant to update or change their rendering engines—are listening to the concerns of email professionals. While progress is likely to be slow, there is finally hope for improved support for HTML and CSS in the inbox.尽管越来越重要，邮件产业自身正在变革之中。这是第一次邮件厂商们对于升级还是改变他们的渲染引擎听取邮件专业人士的意见。虽然进步是缓慢的，但是终于有希望在客户端中提高对HTML和CSS的支持了。Although some problems still need to be addressed, there has never been a better time to take email seriously. For a channel that nearly every business uses, and that most consumers can’t live without, these changes signal an important shift in a thriving industry—one that designers, developers, and strategists for the web should start paying attention to.虽然有一些问题需要解决，但是这从来没有一个更好的事件来认真对待email了。对于一个每个公司都需要使用的渠道，大多数使用者都无法离开的渠道来说，邮件的这些改变信号应该开始被设计者，开发者和web的专家注意了。Let’s look at how these changes are manifesting themselves.让我们看一下这些改变是如何改变他们自己的吧。 The web comes to emailIt’s an old saw that email design is stuck in the past. For the longest time, developers have been forced to revisit coding techniques that were dated even back in the early 2000s if they wanted to build an HTML email campaign. Locked into table-based layouts and reliant on inline styles, most developers refused to believe that email could do anything more than look serviceable and deliver some basic content to subscribers.email的设计被卡在了旧的设计上。在很长时间里，开发者如果想要创建一封HTML邮件，他们需要被强制的使用老旧的技术甚至是2000年之前的技术。锁定在了基于样式的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器渲染流程]]></title>
      <url>%2F2017%2F03%2F02%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[前言浏览器渲染大概分为五个流程，懂得了渲染流程，才能对页面进行更好的优化。下面分条讲述。 DOM浏览器在解析HTML时，会以递增的方式为HTML标记生成一种名为文档对象模型（DOM）的树状模型，该模型描述了网页中包含的内容。 CSSDOM浏览器收到所有CSS后，会对其中包含的标记和和类生成一种名为CSS对象模型的树状模型，并将样式信息附加在树的节点上。这个树描述了网页中所包含内容需要应用的样式。在CSSDOM构造完成之前，客户端上不会显示任何信息。 Render Tree通过将DOM与CSSOM结合在一起，浏览器可以构造出呈现树，其中包含了页面内容以及所要应用的样式信息。 Layout布局这一步中需要计算网页内容在屏幕上的实际位置和大小。 Paint最后一步将使用布局信息在屏幕上绘制像素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[影响web应用程序页面加载速度的因素]]></title>
      <url>%2F2017%2F03%2F02%2F%E5%BD%B1%E5%93%8Dweb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E7%9A%84%E5%9B%A0%E7%B4%A0%2F</url>
      <content type="text"><![CDATA[后端处理（Backend）网站服务器需要花时间从数据库载入数据并生成网页。 网络延迟（Network latency）每个请求需要花时间从客户端抵达服务器并再次返回客户端（请求延迟）。考虑到完整加载一个网站平均需要发出超过100个请求，延迟问题变得更严峻了。 前端处理（Frontend）前端设备渲染网页也需要时间。 在页面中指定预取域名：&lt;link rel=”dns-prefetch” href=”http://this-is-a.com”&amp;gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack构建前端项目]]></title>
      <url>%2F2017%2F03%2F01%2Fwebpack%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[介绍webpack是现在比较流行的前端构建工具，集编译，压缩，模块加载，打包等功能于一体（webpack）。 本文将详细介绍webpack的使用 配置与名词详解 chunk打包完成之后的块 entry构建模块的起点，每一个入口文件对应生成一个chunk。 devtool开发工具 开发与生产环境配置常用命令 webpack --progress --watch 开启监控模式 注意事项 output中的path路径为绝对路径。 exclude中的路径也为绝对路径。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字体相关]]></title>
      <url>%2F2016%2F11%2F04%2F%E5%AD%97%E4%BD%93%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[font-size属性值有100-900,normal、bold、bolder、lighter。normal == 400 bold == 700bolder、lighter表示其字重值是基于从其父元素继承而来的字重计算所得的，与normal、bold所代表的字重并无关系。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Electron]]></title>
      <url>%2F2016%2F11%2F03%2FElectron%2F</url>
      <content type="text"><![CDATA[前言如果你只会JS，还想写一个GUI的话，相信你会喜欢这个技术。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记不住的JS知识点]]></title>
      <url>%2F2016%2F11%2F01%2F%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84jsAPI%2F</url>
      <content type="text"><![CDATA[将字符串分割成数组 1234function* split(string)&#123; yield* string&#125;console.log([...split(&apos;nihao&apos;)]); 或者直接使用扩展操作符 1[...&apos;nihao&apos;] null表示一个空指针对象，用typeof检测的话是object。 true == 1 但是并不等于2.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局]]></title>
      <url>%2F2016%2F10%2F27%2Fflex%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[详细注意设为Flex布局以后，子元素的float、clear和vertical-align属性将失效]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊一聊CSS中的盒模型]]></title>
      <url>%2F2016%2F10%2F27%2F%E8%81%8A%E4%B8%80%E8%81%8ACSS%E4%B8%AD%E7%9A%84%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[前言参考链接：盒模型 box-sizing基本大家都知道盒模型的概念，我就不再多说了，主要说一下其中的box-sizing属性。 box-sizing主要用来改变盒模型对于宽度和高度的计算，在实际中我们可以根据习惯，设置为符合自己计算思路的盒模型计算法则。有俩个值：content-box和border-boxcontent-box：默认值，计算宽度和高度值为content box的高度和宽度，不包括内边距，边框，外边距。border-box：可选值，高度和宽度包括内边距和边框。 各种长度的意思 offsetWidth是一个只读属性，返回一个元素的布局宽度。一个典型的offsetWidth是测量元素的边框(borders)、水平线上的内边距(padding)、竖直方向滚动条(scroolbar)（如果存在的话）、以及CSS设置的宽度(width)的值。 offsetLeft 只读属性，此元素与offsetParent的距离，只包含margin的距离。 clientWidth 属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有的话）、边框和外边距。该属性值会被四舍五入为一个整数。如果你需要一个小数值，可使用 element.getBoundingClientRect()。 innerWidth浏览器视口（viewport）宽度（单位：像素），如果存在垂直滚动条则包括它。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown的基本使用]]></title>
      <url>%2F2016%2F10%2F25%2FMarkDown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、标题markDown的标题用”#”表示# 一级标题## 二级标题### 三级标题#### 四级标题 二、换行 在Markdown中插入换行标签&quot;&lt;br/&gt;&quot; 在行尾输入两个或以上的空格，然后回车 三、缩进 可以在段落前加&quot;- &quot; &amp;nbsp; 半角的不断行的空白格（推荐使用） &amp;ensp; 半角的空格 &amp;emsp; 全角的空格 输入法切换到全角，双击空格键 四、水平线 可以在单独一行里输入3个或以上的短横线、星号或者下划线实现* * ****----_____ 五、输出代码块使用“｀｀｀”符号吧代码段包裹住就可输出不执行了 12var a=1,b=2;console.log(a+b); 使用”`”包裹住方法可以输出方法 getName() 六、引用 如果要在一个引用里插入一个引用，可以用两个(‘&gt;’)开头。依此类推，根据嵌套层次加相应数量的符号。 这是一个引用 这是一个嵌套引用 这是一个嵌套引用 七、链接 链接可以在行内插入 [文字](链接地址) 另一种选择是，链接地址可以放在段落后面的脚注，前面放上链接引用标签区分。举例说，先在内容行内插入以下内容： [链接文字][链接引用标签] 然后在段落的后面（或者文档的结尾）放上以下内容，就可以生成一个链接： [链接引用标签]: 链接地址 &quot;链接标题&quot; 八、禁止转义 当做行内代码来处理添加” ` “ 内容 “ ` “ &amp;nbsp; 九、图片 ![图片描述](图片链接地址) ![](static/file.png)本地链接 十、强调markdown 是一个具有*纯文本标记*特性的**轻量级**标记语言。 呈现效果 markdown 是一个具有纯文本标记特性的轻量级标记语言。 十一、居中 由于markdown没有居中对齐我们只能在内加入&lt;center&gt;内容&lt;/center&gt;标签&lt;center&gt;我是一个被居中的内容&lt;/center&gt;呈现效果: 我是一个被居中的内容 十二、列表 无序列表+ 列表项1- 列表项2* 列表项3 有序列表使用数字后面跟上句号。（还要有空格）1. 2. ...]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue学习记录]]></title>
      <url>%2F2016%2F10%2F23%2Fvue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[前言vue有着近乎同步更新的文档地址。推荐使用官方脚手架搭建项目。本文案例主要讲自己工作的技术栈需要配置的东西。如果依赖被墙，请自行搜索npm淘宝镜像。 依赖插件 sass-loader与node-sass用来处理scss。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[16.10.22]]></title>
      <url>%2F2016%2F10%2F22%2F16-10-22%2F</url>
      <content type="text"><![CDATA[perspective相当于井深，这个属性值越深，表示立体感越深。 ##]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[必备知识收藏]]></title>
      <url>%2F2016%2F10%2F22%2F%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[名词解释 语义化版本 RESTful 生成自签名证书 z-index]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[16.10.21]]></title>
      <url>%2F2016%2F10%2F21%2F16-10-21%2F</url>
      <content type="text"><![CDATA[异常并不会阻碍代码的执行，只是抛出错误信息。 异常要用Error的对象而不要自定义对象，因为只有Err的对象才能获取到上下文。 我们可以为任意的对象添加属性，包括内建对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[facebook新品：yarn]]></title>
      <url>%2F2016%2F10%2F20%2Ffacebook%E6%96%B0%E5%93%81%EF%BC%9Ayarn%2F</url>
      <content type="text"><![CDATA[介绍yarn是facebook出品的js包管理工具。用于替代npm。优势就是安全，下载速度快。 命令npm i -g yarn安装。yarn add $package作用等同于npm i --save $package]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[梳理line-height]]></title>
      <url>%2F2016%2F10%2F02%2F%E6%A2%B3%E7%90%86line-height%2F</url>
      <content type="text"><![CDATA[当没有显示声明line-height的时候]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何禁止chrome的缓存]]></title>
      <url>%2F2016%2F10%2F01%2F%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2chrome%E7%9A%84%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[在我们做一些图片加载效果的过程中，为了每次都让图片重新加载，可以在开发chrome的开发工具里打开更多，然后是more tools，然后是network condictions。在这里可以禁止缓存，并且模拟网速。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML收藏]]></title>
      <url>%2F2016%2F09%2F30%2FHTML%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[HTML5沿革]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小知识合集]]></title>
      <url>%2F2016%2F09%2F11%2F%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86%2F</url>
      <content type="text"><![CDATA[高度的百分比需要继承在父元素未设置高度的情况下，子元素的高度的按百分比显示的话需要将父元素的高度一直写到确切的高度为止。123456789101112html&#123; height: 100%;&#125;body&#123; height: 100%;&#125;.father&#123; height: 100%;&#125;.child&#123; height: 100%;&#125; 宽度无此限制 var的变量提升(hoist)使用var声明的变量的变量会提升到作用域的顶部。例如1234console.log(n);n = &apos;nihao&apos;console.log(n);var n; em的规则font-size的值如果为em，继承的是父级的高度，如果其他值为em的话，根据的是当前元素的font-size的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计类收藏]]></title>
      <url>%2F2016%2F09%2F10%2F%E8%AE%BE%E8%AE%A1%E7%B1%BB%E6%94%B6%E8%97%8F%2F</url>
      <content type="text"><![CDATA[设计更好的表单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vscode使用指南]]></title>
      <url>%2F2016%2F09%2F09%2Fvscode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[简介微软在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code 项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。推荐理由：免费，开源。下载地址 我的设置vsc的个性化设置我感觉还是比较方便的。进入首选项用户设置就可以进行设置。下载完成之后我首先改了对于文件修改保存的设置，默认是需要手动保存的，我改成了自动保存。然后就是默认的shell，对于win10用户我感觉可以换成ubuntu的那个shell，默认应该是和cmd在同一级目录。 插件建议 vscode-icons：这个是一个图标插件，vsc自带的插件对于各种文件的显示效果没有明显的区分。本插件比较好看，可以清楚的辨别各种文件类型。效果如图。 安装好之后在首选项里选择文件主题图标选择本插件就好。 Auto Rename Tag：书写HTML的时候，当更改了开始标签时，闭合标签也会自动改变。 快捷键虽然可以直接在偏好设置里查看默认的键盘快捷键和自定义快捷键，但是估计一票人不会去看。 文本编辑alt+up/down 移动单行shift+alt+up/down 向上或者下复制单行shift+alt+f 格式化文本command++/- 增大或者减小文本字体 文本选择li*10 直接写出10行alt+鼠标选择 选择行command+alt+up/down [size=0.9em]多行选择shift+up/down 选中光标前或者后一行shift+command+left/right 选中左或者右的部分shift+command+down/up 选中光标前面所有或者后面所有内容 文本跳转ctrl+a 跳到本行开始（command＋left）ctrl+e 跳到本行末尾（我自己喜欢用command＋right）command+down/up 跳到开始或者结束的位置 窗口切换command+b 切换二级菜单 命令code .在vscode中打开当前文件夹]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm使用技巧]]></title>
      <url>%2F2016%2F09%2F08%2Fnpm%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[前言本文主要知识来自于文蔺 npm算是前端开发中最常用的一个工具了，掌握一些技巧对于提高编程效率增加幸福感至关重要。 打开npm包的官网在开发中并不是都对每一个包都了如指掌，所以需要经常要去官网看文档npm home $package比如npm home react 打开此包的GitHub地址和上边一个命令差不太多npm repo $package 检查依赖中的过时项npm outdated这个对于我这种升级强迫症来说简直是完美。但是升级需谨慎。 删除无用的依赖项npm prune此命令可以删除node-modules中不在依赖列表中的项，对于实验某些依赖的作用或者删除年少轻狂时犯下的错有很大的作用。 下边是一些常用配置 创建package.json文件npm initnpm init -y两者区别自行尝试 安装依赖npm install --save react安装生产环境依赖npm install --save-dev webpack开发环境依赖npm install -g全局安装tips:install可以简写为i npm脚本既是shell脚本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见网络安全名词介绍]]></title>
      <url>%2F2016%2F09%2F06%2F%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[XSS跨站脚本攻击(Cross Site Scripting) CSRF跨站请求伪造(Cross-site request forgery) SQL注入 CSP网页安全政策(Content Security Policy)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React的生命周期]]></title>
      <url>%2F2016%2F09%2F02%2FReact%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
      <content type="text"><![CDATA[前言tag:本文主要知识源自于chemdemo我认为学习一个库，在初识了语法规范之后，接着要学习的就是生命周期了，生命周期方法告诉了我们在哪个阶段该做什么，对整个应用有一个直观的认识，并能清楚的控制。React的生命周期大体上分为：初始化，挂载，更新，卸载四个阶段。下面我们来看一下这四个阶段的详细方法。 初始化阶段。在这个阶段主要有俩个方法。初始化state123456constructor(props) &#123; super(props) this.state = &#123; name: props.name &#125;&#125; 初始化props123class.defaultProps = &#123; name:&apos;Zyan&apos;&#125; 如果属性没有从父组件传入的话可以直接使用此值作为默认examples:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123;Component, PropTypes&#125; from &apos;react&apos;import ReactDom from &apos;react-dom&apos;;class Lifecycle extends Component &#123; constructor(props) &#123; super(props) console.log(&apos;initstate&apos;) this.state = &#123; name: props.name &#125; &#125; componentWillMount() &#123;&#125; componentDidMount() &#123;&#125; componentWillReceiveProps(nextProps) &#123;&#125; componentWillUpdate(nextProps, nextState) &#123;&#125; componentDidUpdate(prevProps, prevState) &#123;&#125; componentWillUnmount() &#123;&#125; click = (event) =&gt; &#123; this.setState(&#123;name: &quot;ni&quot;&#125;) &#125; render() &#123; console.log(&apos;render&apos;) return ( &lt;div&gt; &#123;this.state.name&#125; &lt;input type=&quot;button&quot; value=&quot;点击&quot; onClick=&#123;this.click&#125;/&gt; &lt;/div&gt; ) &#125;&#125;Lifecycle.propTypes = &#123; name:React.PropTypes.string&#125;Lifecycle.defaultProps = &#123; name:&apos;Zyan&apos;, conduct:function()&#123; console.log(&apos;initProps&apos;) &#125;()&#125;ReactDom.render( &lt;Lifecycle/&gt;, document.querySelector(&apos;#app&apos;)); 同时我们也可以看到执行顺序为props -&gt; state -&gt; render 挂载阶段此阶段有俩个方法可以使用：componentWillMount() 和componentDidMount() componentWillMount()在刚好初始渲染（initial rendering）发生之前被调用一次，也就是React在DOM插入组件之前。需要注意的是在此处调用this.setState()方法将不会触发重复渲染（re-render）componentDidMount()刚好发生在React插入组件到DOM之后，且也只被调用一次。在此方法能够之后DOM树已经构建完成，这意味着这个方法是初始化其他需要访问DOM或操作数据的第三方库的最佳时机。 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount 更新阶段当修改组件的props或者state时，组件将会进行更新。修改props时，会以此执行以下方法：12345componentWillReceiveProps(nextProps) &#123;&#125;shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 当state改变时执行以下方法：1234shouldComponentUpdate(nextProps, nextState) &#123;componentWillUpdate(nextProps, nextState) &#123;&#125;render()&#123;&#125;componentDidUpdate(prevProps, prevState) &#123;&#125; 此时组件已经被插入dom中了，所以这些方法不会在首次render时调用。 shouldComponentUpdate()方法允许我们自行决定下一个state更新时是否触发重复render。详细优化 此时执行的顺序为：props -&gt; state -&gt; willMount -&gt; render -&gt; didMount -&gt; 更新 -&gt;willupdate -&gt; render -&gt; didUpdate 卸载阶段此阶段只有一个方法componentWillUnmount()它将在组件从DOM卸载之前被调用。可以在内部执行任何可能需要的清理工作]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React优化指南]]></title>
      <url>%2F2016%2F09%2F01%2FReact%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[生命周期优化 shouldComponentUpdate(nextProps,nextState)此方法决定当prpos和state改变时是否执行render()。在有一些时候，我们并不需要刷新的时候，可以直接返回false。默认情况下是ture。此方法只会在组件的存在期调用，并不会在初始化期调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM标准事件的三个阶段]]></title>
      <url>%2F2016%2F08%2F26%2FDOM%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[事件捕获从根节点流向目标节点 目标阶段目标节点触发阶段 事件冒泡目标节点回溯到根节点]]></content>
    </entry>

    
  
  
</search>
